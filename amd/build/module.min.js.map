{"version":3,"file":"module.min.js","sources":["../src/module.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * JS for this plugin.\n *\n * @copyright   IntegrityAdvocate.com\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nclass block_quizonepagepaginate {\n    constructor(versionstring, questionsperpage) {\n        const debug = false;\n        const self = this;\n        const fxn = self.constructor.name + '.constructor';\n        window.console.log(fxn + '::Started with versionstring=' + versionstring + '; questionsperpage=' + questionsperpage);\n\n        if (!self.isAQuizAttemptPage()) {\n            debug && window.console.log(fxn + '::We should not use this block JS bc this is not a quiz attempt page');\n            return;\n        }\n\n        if (isNaN(questionsperpage)) {\n            throw new Error(fxn + '::Invalid value passed for param questionsperpage');\n        }\n\n        // How many quiz questions to show at one time.\n        self.questionsperpage = parseInt(questionsperpage);\n        if (self.questionsperpage < 1) {\n            throw new Error(fxn + '::Invalid value passed for param questionsperpage');\n        }\n\n        // The index of the first quiz question to show.\n        self.firstQuestionToShow = 0;\n\n        // Used to locate the quiz questions on the page.\n        self.eltQuestionsSelector = '#page-mod-quiz-attempt #responseform .que';\n        // Used to place this plugin's JS-driven next/prev nav buttons.\n        self.eltQuizFinishAttemptButtonSelector = '#responseform .submitbtns .mod_quiz-next-nav';\n        // Button to show tne previous questions.\n        self.eltBqoppButtonPrev = self.constructor.name + '-prev';\n        // Button to show tne next questions.\n        self.eltBqoppButtonNext = self.constructor.name + '-next';\n\n        // Holds all the current page quiz questions, visible or not.\n        self.arrQuestions = [];\n    }\n\n    run() {\n        const debug = false;\n        const self = this;\n        const fxn = self.constructor.name + '.run';\n        debug && window.console.log(fxn + '::Started with self.firstQuestionToShow=; self.questionsperpage=', self.firstQuestionToShow, self.questionsperpage);\n\n        if (!self.isAQuizAttemptPage() || !self.shouldQuizPaginate()) {\n            window.console.log(fxn + '::We should not use this block JS: self.isAQuizAttemptPage()=' + self.isAQuizAttemptPage() + '; self.shouldQuizPaginate()=' + self.shouldQuizPaginate());\n            return;\n        }\n\n        self.getAllQuestions();\n\n        debug && window.console.log(fxn + '::About to self.addNextPrevButtons()');\n        self.addNextPrevButtons();\n\n        // Handle changes to URL anchor.\n        window.addEventListener('hashchange', self.handleAnchorChange);\n\n        // Find the question index matching the question-* number.\n        const requestedQuestionIndex = self.getAnchorQuestionIndex(document.URL);\n        debug && window.console.log(fxn + '::Got requestedQuestionIndex=', requestedQuestionIndex);\n        if (requestedQuestionIndex >= 0) {\n            self.firstQuestionToShow = requestedQuestionIndex;\n        }\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n    }\n\n    isAQuizAttemptPage() {\n        return document.body.id === 'page-mod-quiz-attempt';\n    }\n\n    shouldQuizPaginate() {\n        const debug = false;\n        const self = this;\n        const fxn = self.constructor.name + '.shouldQuizPaginate';\n        debug && window.console.log(fxn + '::Started');\n\n        let shouldQuizPaginate = false;\n\n        // Populate self.arrQuestions if not already done.\n        self.getAllQuestions();\n\n        shouldQuizPaginate = self.questionsperpage < self.arrQuestions.length;\n        debug && window.console.log(fxn + '::Got self.questionsperpage=' + self.questionsperpage + ' is it < self.arrQuestions.length=' + self.arrQuestions.length, shouldQuizPaginate);\n\n        return shouldQuizPaginate;\n    }\n\n    /**\n     * If the URL anchor value matches /question-\\d+-\\d+/, get the index of the self.arrQuestions item that matches.\n     *\n     * @param {string} url URL containing the anchor e.g. \"https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#question-23-9\".\n     * @returns {number} The matching index in self.arrQuestions; else -1.\n     */\n    getAnchorQuestionIndex(url = '') {\n        const debug = false;\n        const self = this;\n        const fxn = self.constructor.name + '.getAnchorQuestionIndex';\n        debug && window.console.log(fxn + '::Started');\n\n        let questionIndex = -1;\n\n        const anchor = self.getAnchor(url);\n        debug && window.console.log(fxn + '::Got anchor=', anchor);\n        if (!anchor || anchor.length < 'question-1-1'.length) {\n            debug && window.console.log(fxn + '::No anchor  so return questionIndex=', questionIndex);\n            return questionIndex;\n        }\n\n        const questionNrRequested = self.getAnchorQuestionNr(anchor);\n        if (!questionNrRequested) {\n            return questionIndex;\n        }\n\n        questionIndex = self.findQuestionIndexFromQuestionNr(questionNrRequested);\n\n        return questionIndex;\n    }\n\n    /**\n     * Get the URL anchor value.\n     *\n     * @param {string} url A URL to get the anchor value from e.g. \"https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#blah\".\n     * @returns {string} The URL anchor value (e.g. \"blah\" in url=https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#blah); else return empty string.\n     */\n    getAnchor(url = '') {\n        if (!url || url.length < 1 || typeof url !== 'string') {\n            return '';\n        }\n\n        const anchor = url.split(\"#\")[1];\n        return anchor ? anchor : \"\";\n    }\n\n    /**\n     * Extract the question sequence number from the URL anchor text.\n     *\n     * @param {string} anchor The URL anchor string (e.g. \"blah\" in url=https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#blah).\n     * @returns {string} The question number e.g. \"question-23-9\" from the URL anchor value (e.g. from https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#question-23-9); else return empty string.\n     */\n    getAnchorQuestionNr(anchor = '') {\n        const debug = false;\n        const self = this;\n        const fxn = self.constructor.name + '.getAnchorQuestionNr';\n        debug && window.console.log(fxn + '::Started');\n\n        // This value is in the format mm-nn where mm=the quiz attempt number; nn=the question index.\n        let questionNrRequested = '';\n\n        if (anchor && anchor.length > 2) {\n            const regexResults = anchor.match(/(question-\\d+-\\d+)/);\n            debug && window.console.log(fxn + '::Got regexResults=', regexResults);\n            if (regexResults) {\n                questionNrRequested = regexResults[1];\n            }\n        }\n        debug && window.console.log(fxn + '::Got questionNrRequested=', questionNrRequested);\n\n        return questionNrRequested;\n    }\n\n    /**\n     * Search self.arrQuestions for a question with number=questionNr.\n     *\n     * @param {str} questionNr The question number e.g. \"question-23-9\".\n     * @returns {number} The index of self.arrQuestions that matches; else -1.\n     */\n    findQuestionIndexFromQuestionNr(questionNr = '') {\n        const debug = false;\n        const self = this;\n        const fxn = self.constructor.name + '.findQuestionIndexFromQuestionNr';\n        debug && window.console.log(fxn + '::Started with questionNr=', questionNr);\n\n        let indexFound = -1;\n\n        if (!questionNr || typeof questionNr !== 'string' || questionNr.length < 'question-1-1'.length) {\n            window.console.log(fxn + '::Invalid value passed for questionNr so return not found');\n            return indexFound;\n        }\n        if (self.arrQuestions.length < 1) {\n            window.console.log(fxn + '::arrQuestions is empty so return not found');\n            return indexFound;\n        }\n\n        self.arrQuestions.forEach((elt, index) => {\n            debug && window.console.log(fxn + '::Looking at index=' + index + '; elt=', elt);\n            if (elt.id === questionNr) {\n                debug && window.console.log(fxn + '.forEach::Found matching index=', index);\n                indexFound = index;\n                return;\n            }\n        });\n\n        debug && window.console.log(fxn + '::About to return indexFound=', indexFound);\n        return indexFound;\n    }\n\n    getAllQuestions() {\n        const debug = false;\n        const self = this;\n        const fxn = self.constructor.name + '.getAllQuestions';\n        debug && window.console.log(fxn + '::Started');\n\n        // If self.arrQuestions is already populated, just return it.\n        if (typeof self.arrQuestions != 'undefined' && self.arrQuestions.length > 0) {\n            debug && window.console.log(fxn + '::self.arrQuestions is already populated so just return it');\n            return self.arrQuestions;\n        }\n\n        self.arrQuestions = document.querySelectorAll(self.eltQuestionsSelector);\n        debug && window.console.log(fxn + '::Found ' + self.arrQuestions.length + ' questions on the page');\n\n        return self.arrQuestions;\n    }\n\n    hideShowQuestions(first = 0, length) {\n        const debug = false;\n        const self = M.block_quizonepagepaginate;\n        const fxn = self.constructor.name + '.hideShowQuestions';\n        debug && window.console.log(fxn + '::Started with first=' + first + '; length=' + length);\n\n        if (isNaN(first) || isNaN(length) || first < 0 || length < 1) {\n            throw new Error(fxn + '::Invalid value passed for param first or length');\n        }\n        if (self.arrQuestions.length < 1) {\n            throw new Error(fxn + '::self.arrQuestions is empty');\n        }\n\n        const last = first + length;\n        let countVisible = 0;\n\n        self.arrQuestions.forEach((elt, index) => {\n            debug && window.console.log(fxn + '::Looking at question index=' + index + '; elt=', elt);\n            if (index >= first && index < last && countVisible < self.questionsperpage) {\n                debug && window.console.log(fxn + '::Show this elt  ', elt);\n                elt.classList.remove('quizonepage-hidden');\n                countVisible++;\n            } else {\n                debug && window.console.log(fxn + '::Hide this elt', elt);\n                elt.classList.add('quizonepage-hidden');\n            }\n        });\n\n        // Update button visibility after showing/hiding questions.\n        self.updatePrevNextButtonVisibility();\n    }\n\n    addNextPrevButtons() {\n        const debug = false;\n        const self = this;\n        const fxn = self.constructor.name + '.addNextPrevButtons';\n        debug && window.console.log(fxn + '::Started with self.eltQuizFinishAttemptButtonSelector=', self.eltQuizFinishAttemptButtonSelector);\n\n        const eltCloneSource = document.querySelector(self.eltQuizFinishAttemptButtonSelector);\n        if (eltCloneSource === null) {\n            throw new Error(fxn + '::No button found to clone');\n        }\n\n        // String are returned in a plain array in the same order specified here.\n        // E.g. [0 => \"Previous\", 1 => \"Next\"].\n        const stringsToRetrieve = [{\n            key: 'previous',\n            component: 'core'\n        },\n        {\n            key: 'next',\n            component: 'core',\n        }\n        ];\n\n        // We need core/str bc we use some of the strings for the UI.\n        require(['core/str'], function(str) {\n            debug && window.console.log(fxn + '.require::Started with stringsToRetrieve=', stringsToRetrieve);\n\n            str.get_strings(stringsToRetrieve).then(\n                function(stringsRetrieved) {\n                    debug && window.console.log(fxn + '.require.get_strings.then::Started with stringsRetrieved=', stringsRetrieved);\n\n                    const eltPrevInDom = self.addPrevNextButton(eltCloneSource, 'prev', stringsRetrieved);\n                    eltPrevInDom.addEventListener('click', self.buttonClickedPrev);\n\n                    const eltNextInDom = self.addPrevNextButton(eltCloneSource, 'next', stringsRetrieved);\n                    eltNextInDom.addEventListener('click', self.buttonClickedNext);\n\n                    return stringsRetrieved;\n                }).catch(function(err) {\n                    console.error(fxn + '::Failed to get strings', err);\n                    throw err; // Re-throw to propagate error\n                });\n        });\n    }\n\n    /**\n     * Add buttons to the page to JS-navigate through the quiz questions on the page.\n     *\n     * @param {DomElement} eltCloneSource An existing button in the form buttons area.\n     * @param {string} nextorprev Which button to create; valid values=[prev, next]\n     * @param {Array<string>} strings Moodle lang strings for the buttons in the order they are created.\n     * @returns {DomElement} The DomElement we just inserted.\n     */\n    addPrevNextButton(eltCloneSource, nextorprev, strings) {\n        const debug = false;\n        const self = M.block_quizonepagepaginate;\n        const fxn = self.constructor.name + '.addPrevNextButton';\n        debug && window.console.log(fxn + '::Started wih eltCloneSource=; nextorprev=; strings=', eltCloneSource, nextorprev, strings);\n\n        // Validate params.\n        if (!(eltCloneSource instanceof Element)) {\n            throw new Error(fxn + '::Invalid value passed for param eltCloneSource');\n        }\n        if (nextorprev !== 'prev' && nextorprev !== 'next') {\n            throw new Error(fxn + '::Invalid value passed for param nextorprev');\n        }\n        if (!Array.isArray(strings) || strings.length < 2) {\n            throw new Error(fxn + '::Invalid value passed for param strings');\n        }\n        debug && window.console.log(fxn + '::Done validating params');\n\n        const isPrev = nextorprev === 'prev';\n        const btnname = (isPrev ? self.eltBqoppButtonPrev : self.eltBqoppButtonNext);\n        const btnvalue = strings[(isPrev ? 0 : 1)];\n\n        // The param=true keeps attributes but not listeners.\n        const eltClone = eltCloneSource.cloneNode(true);\n        eltClone.setAttribute('id', btnname);\n        eltClone.className = eltClone.className.replace('btn-primary', 'btn-secondary');\n        // Prevent block_integrityadvocate and other from binding these buttons. As of Moodle 5 this matches both Previous and Next buttons in the classic theme.\n        eltClone.className = eltClone.className.replace('mod_quiz-next-nav', 'block_quizonepagepaginate-' + nextorprev);\n        eltClone.name = btnname;\n        eltClone.type = 'button'; // Prevents MacOS from navigating when type=submit.\n        eltClone.setAttribute('value', btnvalue); // Safari fix.\n        eltClone.setAttribute('data-initial-value', btnvalue);\n        eltClone.removeAttribute('disabled');\n\n        // Update button visibility after adding.\n        self.updatePrevNextButtonVisibility();\n\n        return eltCloneSource.parentNode.insertBefore(eltClone, eltCloneSource);\n    }\n\n    updatePrevNextButtonVisibility() {\n        const debug = false;\n        const self = M.block_quizonepagepaginate;\n        const fxn = self.constructor.name + '.updatePrevNextButtonVisibility';\n        debug && window.console.log(fxn + '::Started');\n\n        const prevBtn = document.getElementById(self.eltBqoppButtonPrev);\n        const nextBtn = document.getElementById(self.eltBqoppButtonNext);\n\n        if (prevBtn) {\n            if (self.firstQuestionToShow <= 0) {\n                prevBtn.setAttribute('disabled', 'disabled');\n                prevBtn.classList.add('disabled');\n            } else {\n                prevBtn.removeAttribute('disabled');\n                prevBtn.classList.remove('disabled');\n            }\n        }\n        if (nextBtn) {\n            const lastPageStart = self.arrQuestions.length - self.questionsperpage;\n            if (self.firstQuestionToShow >= lastPageStart) {\n                nextBtn.setAttribute('disabled', 'disabled');\n                nextBtn.classList.add('disabled');\n            } else {\n                nextBtn.removeAttribute('disabled');\n                nextBtn.classList.remove('disabled');\n            }\n        }\n    }\n\n    buttonClickedPrev() {\n        const debug = false;\n        const self = M.block_quizonepagepaginate;\n        const fxn = self.constructor.name + '.buttonClickedPrev';\n        debug && window.console.log(fxn + '::Started');\n\n        self.triggerAutosave();\n        self.updateVisibleQuestionRange(false);\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n        self.updatePrevNextButtonVisibility();\n    }\n\n    buttonClickedNext() {\n        const debug = false;\n        const self = M.block_quizonepagepaginate;\n        const fxn = self.constructor.name + '.buttonClickedNext';\n        debug && window.console.log(fxn + '::Started');\n\n        self.triggerAutosave();\n        debug && window.console.log(fxn + '::Done triggerAutosave');\n        self.updateVisibleQuestionRange(true);\n        debug && window.console.log(fxn + '::Done updateVisibleQuestionRange');\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n        debug && window.console.log(fxn + '::Done hideShowQuestions');\n        self.updatePrevNextButtonVisibility();\n        debug && window.console.log(fxn + '::Done updatePrevNextButtonVisibility');\n    }\n\n    triggerAutosave() {\n        const debug = false;\n        const self = M.block_quizonepagepaginate;\n        const fxn = self.constructor.name + '.triggerAutosave';\n        debug && window.console.log(fxn + '::Started');\n\n        try {\n            debug && window.console.log(fxn + '::About to trigger autosave');\n            M.mod_quiz.autosave.save_changes();\n        } catch (error) {\n            window.console.log(fxn + '::autosave is disabled');\n        }\n    }\n\n    updateVisibleQuestionRange(getNextSet = true) {\n        const debug = false;\n        const self = M.block_quizonepagepaginate;\n        const fxn = self.constructor.name + '.updateVisibleQuestionRange';\n        debug && window.console.log(fxn + '::Started with getNextSet=', getNextSet);\n\n        const firstOfAllQs = 0;\n        const lengthToShow = self.questionsperpage;\n        const lastOfAllQs = self.arrQuestions.length;\n        debug && window.console.log(fxn + '::Start; firstOfAllQs=' + firstOfAllQs + '; lengthToShow=' + lengthToShow + '; lastOfAllQs=' + lastOfAllQs);\n\n        if (getNextSet) {\n            // Propose to jump to the next set of questions.\n            const proposedStart = self.firstQuestionToShow + lengthToShow;\n            debug && window.console.log(fxn + '::Proposed start of the next set of questions=', proposedStart);\n\n            // Check that the [proposed range of setLength questions] is within the [total range of questions].\n            if (proposedStart + lengthToShow < lastOfAllQs) {\n                self.firstQuestionToShow = proposedStart;\n                debug && window.console.log(fxn + '::The proposedStart + lengthToShow is below the max range, so set self.firstQuestionToShow=', self.firstQuestionToShow);\n            } else {\n                self.firstQuestionToShow = lastOfAllQs - lengthToShow;\n                debug && window.console.log(fxn + '::The proposedStart + lengthToShow is above the max range, so set self.firstQuestionToShow=', self.firstQuestionToShow);\n            }\n        } else {\n            // Propose to jump to the next set of questions.\n            const proposedStart = self.firstQuestionToShow - lengthToShow;\n            window.console.log(fxn + '::Proposed start of the next set of questions=', proposedStart);\n\n            // Check that the [proposed range of setLength questions] is within the [total range of questions].\n            if (proposedStart < firstOfAllQs) {\n                debug && window.console.log(fxn + '::The proposedStart is below the min range, so set self.firstQuestionToShow=', self.firstQuestionToShow);\n                self.firstQuestionToShow = firstOfAllQs;\n            } else {\n                debug && window.console.log(fxn + '::The proposedStart is within the min range, so set self.firstQuestionToShow=', self.firstQuestionToShow);\n                self.firstQuestionToShow = proposedStart;\n            }\n        }\n\n        debug && window.console.log(fxn + '::Done; firstOfAllQs=' + firstOfAllQs + '; lengthToShow=' + lengthToShow + '; lastOfAllQs=' + lastOfAllQs);\n    }\n\n    /**\n     * If the user clicks a quiz navigation block link or types in a URL anchor, handle it here.\n     * @param {*} e Event object from the event listener.\n     * @returns void\n     */\n    handleAnchorChange(e) {\n        const debug = false;\n        const self = M.block_quizonepagepaginate;\n        const fxn = self.constructor.name + '.handleAnchorChange';\n        debug && window.console.log(fxn + '::Started with e=', e);\n\n        const target = e.target || e.srcElement;\n        debug && window.console.log('Found target=', target);\n\n        // Only continue if are working from a valid source.\n        let foundHref = '';\n\n        // Handle typed-in URL anchor changes.\n        if (self.isWindowObj(target)) {\n            foundHref = window.location.href;\n            debug && window.console.log(fxn + '::Found window href=', foundHref);\n        }\n\n        // Handle mod_quiz_navblock anchor clicks.\n        if (foundHref.length < 1) {\n            // Is target a child of a mod_quiz_navblock instance?\n            const eltBlock = target.closest('#mod_quiz_navblock');\n            if (!eltBlock) {\n                debug && window.console.log('The target is not a child of the quiz navigation block so just return');\n                return;\n            }\n\n            // In mod_quiz_navblock the target is a span that is a child of the a element, so get the a element and check it is a Quiz Navigation button.\n            const closestA = target.closest('a.qnbutton');\n            debug && window.console.log('Found closestA=', closestA);\n            if (!closestA) {\n                debug && window.console.log('This is not a targeted element so just return');\n                return;\n            }\n\n            foundHref = closestA.href;\n            debug && window.console.log('Found foundHref', foundHref);\n        }\n\n        if (foundHref.length < 1) {\n            debug && window.console.log('No valid href found so just return');\n            return;\n        }\n\n        const requestedQuestionIndex = self.getAnchorQuestionIndex(foundHref);\n        debug && window.console.log(fxn + '::Got requestedQuestionIndex=', requestedQuestionIndex);\n        if (requestedQuestionIndex >= 0) {\n            self.firstQuestionToShow = requestedQuestionIndex;\n        }\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n    }\n\n    isWindowObj(obj) {\n        return obj && obj.document && obj.location && obj.alert && obj.setInterval;\n    }\n}\n\n/**\n * Setup the module.\n *\n * @param {string} versionstring The Moodle version string e.g. \"2022090900\".\n * @param {number} questionsperpage How many quiz questions to show at once.\n */\nexport const init = (versionstring, questionsperpage) => {\n    const debug = false;\n    const fxn = 'block_quizonepagepaginate::init';\n    debug && window.console.log(fxn + '::Started with versionstring=' + versionstring + '; questionsperpage=' + questionsperpage);\n\n    try {\n        M.block_quizonepagepaginate = new block_quizonepagepaginate(versionstring, questionsperpage);\n        // Disabled bc not needed: debug && window.console.log('M.block_quizonepagepaginate::Built class=', M.block_quizonepagepaginate);\n        M.block_quizonepagepaginate.run();\n    } catch (e) {\n        window.console.error(e);\n    }\n};\n"],"names":["block_quizonepagepaginate","constructor","versionstring","questionsperpage","fxn","this","name","window","console","log","isAQuizAttemptPage","isNaN","Error","parseInt","firstQuestionToShow","eltQuestionsSelector","eltQuizFinishAttemptButtonSelector","eltBqoppButtonPrev","eltBqoppButtonNext","arrQuestions","run","self","shouldQuizPaginate","getAllQuestions","addNextPrevButtons","addEventListener","handleAnchorChange","requestedQuestionIndex","getAnchorQuestionIndex","document","URL","hideShowQuestions","body","id","length","url","questionIndex","anchor","getAnchor","questionNrRequested","getAnchorQuestionNr","findQuestionIndexFromQuestionNr","split","regexResults","match","questionNr","indexFound","forEach","elt","index","querySelectorAll","first","M","last","countVisible","classList","remove","add","updatePrevNextButtonVisibility","eltCloneSource","querySelector","stringsToRetrieve","key","component","require","str","get_strings","then","stringsRetrieved","addPrevNextButton","buttonClickedPrev","buttonClickedNext","catch","err","error","nextorprev","strings","Element","Array","isArray","isPrev","btnname","btnvalue","eltClone","cloneNode","setAttribute","className","replace","type","removeAttribute","parentNode","insertBefore","prevBtn","getElementById","nextBtn","lastPageStart","triggerAutosave","updateVisibleQuestionRange","mod_quiz","autosave","save_changes","getNextSet","lengthToShow","lastOfAllQs","proposedStart","e","target","srcElement","foundHref","isWindowObj","location","href","closest","closestA","obj","alert","setInterval"],"mappings":"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"}