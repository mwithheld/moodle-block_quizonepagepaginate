{"version":3,"file":"module.min.js","sources":["../src/module.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * JS for this plugin.\n *\n * @copyright   IntegrityAdvocate.com\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n/* global window, M */\n/* eslint-env es6, node */\n/* eslint-disable no-control-regex, no-alert, max-len */\n\nclass block_quizonepagepaginate {\n    constructor(questionsperpage) {\n        let debug = false;\n        const self = this;\n        const FXN = self.constructor.name + '.constructor';\n        if (debug) { window.console.log(FXN + '::Started with questionsperpage=', questionsperpage); }\n\n        if (!self.shouldUseThisBlockJs()) {\n            if (debug) { window.console.log(FXN + '::We should not use this block JS'); }\n            return;\n        }\n\n        if (isNaN(questionsperpage)) {\n            throw FXN + '::Invalid value passed for param questionsperpage';\n        }\n\n        // How many quiz questions to show at one time.\n        self.questionsperpage = parseInt(questionsperpage);\n        // The index of the first quiz question to show.\n        self.firstQuestionToShow = 0;\n\n        // Used to locate the quiz questions on the page.\n        self.eltQuestionsSelector = '#page-mod-quiz-attempt #responseform .que';\n        // Used to place this plugin's JS-driven next/prev nav buttons.\n        self.eltQuizFinishAttemptButtonSelector = '#responseform .submitbtns .mod_quiz-next-nav';\n        // Button to show tne previous questions.\n        self.eltBqoppButtonPrev = self.constructor.name + '-prev';\n        // Button to show tne next questions.\n        self.eltBqoppButtonNext = self.constructor.name + '-next';\n\n        // Holds all the current page quiz questions, visible or not.\n        self.arrQuestions = [];\n    }\n\n    run() {\n        let debug = false;\n        const self = this;\n        const FXN = self.constructor.name + '.run';\n        if (debug) { window.console.log(FXN + '::Started with self.firstQuestionToShow=; self.questionsperpage=', self.firstQuestionToShow, self.questionsperpage); }\n\n        if (!self.shouldUseThisBlockJs()) {\n            if (debug) { window.console.log(FXN + '::We should not use this block JS'); }\n            return;\n        }\n\n        self.getAllQuestions();\n        self.addNextPrevButtons();\n\n        // Handle changes to URL anchor.\n        window.addEventListener('hashchange', self.handleAnchorChange);\n\n        // Find the question index matching the question-* number.\n        const requestedQuestionIndex = self.getAnchorQuestionIndex(document.URL);\n        if (debug) { window.console.log(FXN + '::Got requestedQuestionIndex=', requestedQuestionIndex); }\n        if (requestedQuestionIndex >= 0) {\n            self.firstQuestionToShow = requestedQuestionIndex;\n        }\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n    }\n\n    shouldUseThisBlockJs() {\n        let debug = false;\n        const self = this;\n        const FXN = self.constructor.name + '.getAnchorQuestionIndex';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        // Use a result cache bc we will use it in the constructor and run() methods.\n        if (typeof self.shouldUseThisBlockJsVal == undefined) {\n            if (debug) { window.console.log(FXN + '::The self.shouldUseThisBlockJs is defined with val=', self.shouldUseThisBlockJsVal); }\n            return self.shouldUseThisBlockJsVal;\n        }\n        self.shouldUseThisBlockJsVal = document.body.id === 'page-mod-quiz-attempt';\n        if (debug) { window.console.log(FXN + '::Got self.shouldUseThisBlockJs=', self.shouldUseThisBlockJsVal); }\n        return self.shouldUseThisBlockJsVal;\n    }\n\n    /**\n     * If the URL anchor value matches /question-\\d+-\\d+/, get the index of the self.arrQuestions item that matches.\n     *\n     * @param {string} url URL containing the anchor e.g. \"https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#question-23-9\".\n     * @returns {number} The matching index in self.arrQuestions; else -1.\n     */\n    getAnchorQuestionIndex(url = '') {\n        let debug = false;\n        const self = this;\n        const FXN = self.constructor.name + '.getAnchorQuestionIndex';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        let questionIndex = -1;\n\n        const anchor = self.getAnchor(url);\n        if (debug) { window.console.log(FXN + '::Got anchor=', anchor); }\n        if (!anchor || anchor.length < 'question-1-1'.length) {\n            return questionIndex;\n        }\n\n        const questionNrRequested = self.getAnchorQuestionNr(anchor);\n        if (!questionNrRequested) {\n            return questionIndex;\n        }\n\n        questionIndex = self.findQuestionIndexFromQuestionNr(questionNrRequested);\n\n        return questionIndex;\n    }\n\n    /**\n     * Get the URL anchor value.\n     *\n     * @param {string} url A URL to get the anchor value from e.g. \"https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#blah\".\n     * @returns {string} The URL anchor value (e.g. \"blah\" in url=https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#blah); else return empty string.\n     */\n    getAnchor(url = '') {\n        return (url.split('#').length > 1) ? url.split('#')[1] : null;\n    }\n\n    /**\n     * Extract the question sequence number from the URL anchor text.\n     *\n     * @param {string} anchor The URL anchor string (e.g. \"blah\" in url=https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#blah).\n     * @returns {string} The question number e.g. \"question-23-9\" from the URL anchor value (e.g. from https://my.moodle.com/mod/quiz/attempt.php?attempt=58&cmid=3#question-23-9); else return empty string.\n     */\n    getAnchorQuestionNr(anchor = '') {\n        let debug = false;\n        const self = this;\n        const FXN = self.constructor.name + '.getAnchorQuestionNr';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        // This value is in the format mm-nn where mm=the quiz attempt number; nn=the question index.\n        let questionNrRequested = '';\n\n        if (anchor && anchor.length > 2) {\n            const regexResults = anchor.match(/(question-\\d+-\\d+)/);\n            if (debug) { window.console.log(FXN + '::Got regexResults=', regexResults); }\n            if (regexResults) {\n                questionNrRequested = regexResults[1];\n            }\n        }\n        if (debug) { window.console.log(FXN + '::Got questionNrRequested=', questionNrRequested); }\n\n        return questionNrRequested;\n    }\n\n    /**\n     * Search self.arrQuestions for a question with number=questionNr.\n     *\n     * @param {str} questionNr The question number e.g. \"question-23-9\".\n     * @returns {number} The index of self.arrQuestions that matches; else -1.\n     */\n    findQuestionIndexFromQuestionNr(questionNr = '') {\n        let debug = false;\n        const self = this;\n        const FXN = self.constructor.name + '.findQuestionIndexFromQuestionNr';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        let indexFound = -1;\n\n        if (!questionNr) {\n            window.console.log(FXN + '::Invalid value passed for param questionNr so return not found');\n            return indexFound;\n        }\n        if (self.arrQuestions.length < 1) {\n            window.console.log(FXN + '::arrQuestions is empty so return not found');\n            return indexFound;\n        }\n\n        self.arrQuestions.forEach(function(elt, index) {\n            if (debug) { window.console.log(FXN + '::Looking at index=; elt=', index, elt); }\n            if (elt.id === questionNr) {\n                if (debug) { window.console.log(FXN + '.forEach::Found matching index=', index); }\n                indexFound = index;\n                return;\n            }\n        });\n\n        if (debug) { window.console.log(FXN + '::About to return indexFound=', indexFound); }\n        return indexFound;\n    }\n\n    getAllQuestions() {\n        let debug = false;\n        const self = this;\n        const FXN = self.constructor.name + '.getAllQuestions';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        self.arrQuestions = document.querySelectorAll(self.eltQuestionsSelector);\n        if (debug) { window.console.log(FXN + '::Found ' + self.arrQuestions.length + ' questions on the page'); }\n    }\n\n    hideShowQuestions(first = 0, length) {\n        let debug = false;\n        const self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.hideShowQuestions';\n        if (debug) { window.console.log(FXN + '::Started with start=; length=', first, length); }\n\n        const last = first + length;\n        let countVisible = 0;\n\n        self.arrQuestions.forEach(function(elt, index) {\n            if (debug) { window.console.log(FXN + '::Looking at index=; elt=', index, elt); }\n            if (index >= first && index < last && countVisible < self.questionsperpage) {\n                if (debug) { window.console.log(FXN + '::Show this elt'); }\n                self.setDisplayVal(elt, 'block');\n                countVisible++;\n            } else {\n                if (debug) { window.console.log(FXN + '::Hide this elt'); }\n                self.setDisplayVal(elt, 'none');\n            }\n        });\n    }\n\n    scrollToQuestion(anchor = '') {\n        if (anchor.length < 1) {\n            document.querySelector('#responseform').scrollIntoView({\n                behavior: 'smooth'\n            });\n        }\n    }\n\n    setDisplayVal(elt, displayVal) {\n        elt.style.display = displayVal;\n    }\n\n    addNextPrevButtons() {\n        let debug = false;\n        const self = this;\n        const FXN = self.constructor.name + '.addNextPrevButtons';\n        if (debug) { window.console.log(FXN + '::Started with self.eltQuizFinishAttemptButtonSelector=', self.eltQuizFinishAttemptButtonSelector); }\n\n        const eltCloneSource = document.querySelector(self.eltQuizFinishAttemptButtonSelector);\n        if (eltCloneSource === null) {\n            throw FXN + '::No button found to clone';\n        }\n\n        // String are returned in a plain array in the same order specified here.\n        // E.g. [0 => \"Previous\", 1 => \"Next\"].\n        const stringsToRetrieve = [{\n                key: 'previous',\n                component: 'core'\n            },\n            {\n                key: 'next',\n                component: 'core',\n            }\n        ];\n\n        // We need core/str bc we get column names via ajax get_string later.\n        require(['core/str'], function(str) {\n            if (debug) { window.console.log(FXN + '.require::Started with stringsToRetrieve=', stringsToRetrieve); }\n\n            str.get_strings(stringsToRetrieve).then(\n                function(stringsRetrieved) {\n                    if (debug) { window.console.log(FXN + '.require.get_strings.then::Started with stringsRetrieved=', stringsRetrieved); }\n\n                    const eltPrevInDom = self.addPrevNextButton(eltCloneSource, 'prev', stringsRetrieved);\n                    eltPrevInDom.addEventListener('click', self.buttonClickedPrev);\n\n                    const eltNextInDom = self.addPrevNextButton(eltCloneSource, 'next', stringsRetrieved);\n                    eltNextInDom.addEventListener('click', self.buttonClickedNext);\n                });\n        });\n    }\n\n    /**\n     * Add buttons to the page to JS-navigate through the quiz questions on the page.\n     *\n     * @param {DomElement} eltCloneSource An existing button in the form buttons area.\n     * @param {string} nextorprev Which button to create; valid values=[prev, next]\n     * @param {Array<string>} strings Moodle lang strings for the buttons in the order they are created.\n     * @returns {DomElement} The DomElement we just inserted.\n     */\n    addPrevNextButton(eltCloneSource, nextorprev, strings) {\n        let debug = false;\n        const self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.addPrevNextButton';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        const eltClone = eltCloneSource.cloneNode();\n        const isPrev = nextorprev === 'prev';\n        const prevval = (isPrev ? self.eltBqoppButtonPrev : self.eltBqoppButtonNext);\n        const prevdisplay = strings[(isPrev ? 0 : 1)];\n        eltClone.setAttribute('id', prevval);\n        eltClone.setAttribute('class', eltClone.getAttribute('class').replace('btn-primary', 'btn-secondary'));\n        eltClone.setAttribute('name', prevval);\n        eltClone.setAttribute('type', prevval);\n        eltClone.setAttribute('value', prevdisplay);\n        eltClone.setAttribute('data-initial-value', prevdisplay);\n\n        return eltCloneSource.parentNode.insertBefore(eltClone, eltCloneSource);\n    }\n\n    buttonClickedPrev() {\n        let debug = false;\n        const self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.buttonClickedPrev';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        self.updateVisibleQuestionRange(false);\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n        self.scrollToQuestion();\n    }\n\n    buttonClickedNext() {\n        let debug = false;\n        const self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.buttonClickedNext';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        self.updateVisibleQuestionRange(true);\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n        self.scrollToQuestion();\n    }\n\n    updateVisibleQuestionRange(getNextSet = true) {\n        let debug = false;\n        const self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.updateVisibleQuestionRange';\n        if (debug) { window.console.log(FXN + '::Started with getNextSet=', getNextSet); }\n\n        const firstOfAllQs = 0;\n        const lengthToShow = self.questionsperpage;\n        const lastOfAllQs = self.arrQuestions.length;\n        if (debug) { window.console.log(FXN + '::Start; firstOfAllQs=' + firstOfAllQs + '; lengthToShow=' + lengthToShow + '; lastOfAllQs=' + lastOfAllQs); }\n\n        if (getNextSet) {\n            // Propose to jump to the next set of questions.\n            const proposedStart = self.firstQuestionToShow + lengthToShow;\n            if (debug) { window.console.log(FXN + '::Proposed start of the next set of questions=', proposedStart); }\n\n            // Check that the [proposed range of setLength questions] is within the [total range of questions].\n            if (proposedStart + lengthToShow < lastOfAllQs) {\n                self.firstQuestionToShow = proposedStart;\n                if (debug) { window.console.log(FXN + '::The proposedStart + lengthToShow is below the max range, so set self.firstQuestionToShow=', self.firstQuestionToShow); }\n            } else {\n                self.firstQuestionToShow = lastOfAllQs - lengthToShow;\n                if (debug) { window.console.log(FXN + '::The proposedStart + lengthToShow is above the max range, so set self.firstQuestionToShow=', self.firstQuestionToShow); }\n            }\n        } else {\n            // Propose to jump to the next set of questions.\n            const proposedStart = self.firstQuestionToShow - lengthToShow;\n            window.console.log(FXN + '::Proposed start of the next set of questions=', proposedStart);\n\n            // Check that the [proposed range of setLength questions] is within the [total range of questions].\n            if (proposedStart < firstOfAllQs) {\n                if (debug) { window.console.log(FXN + '::The proposedStart is below the min range, so set self.firstQuestionToShow=', self.firstQuestionToShow); }\n                self.firstQuestionToShow = firstOfAllQs;\n            } else {\n                if (debug) { window.console.log(FXN + '::The proposedStart is within the min range, so set self.firstQuestionToShow=', self.firstQuestionToShow); }\n                self.firstQuestionToShow = proposedStart;\n            }\n        }\n\n        if (debug) { window.console.log(FXN + '::Done; firstOfAllQs=' + firstOfAllQs + '; lengthToShow=' + lengthToShow + '; lastOfAllQs=' + lastOfAllQs); }\n    }\n\n    handleAnchorChange(e) {\n        let debug = false;\n        const self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.handleAnchorChange';\n        if (debug) { window.console.log(FXN + '::Started with e=', e); }\n\n        const target = e.target || e.srcElement;\n        if (debug) { window.console.log('Found target=', target); }\n\n        // Only continue if are working from a valid source.\n        let foundHref = '';\n\n        // Handle typed-in URL anchor changes.\n        if (self.isWindowObj(target)) {\n            foundHref = window.location.href;\n            if (debug) { window.console.log(FXN + '::Found window href=', foundHref); }\n        }\n\n        // Handle mod_quiz_navblock anchor clicks.\n        if (foundHref.length < 1) {\n            // Is target a child of a mod_quiz_navblock instance?\n            const eltBlock = target.closest('#mod_quiz_navblock');\n            if (!eltBlock) {\n                if (debug) { window.console.log('The target is not a child of the quiz navigation block so skip out'); }\n                return;\n            }\n\n            // In mod_quiz_navblock the target is a span that is a child of the a element, so get the a element and check it is a Quiz Navigation button.\n            const closestA = target.closest('a.qnbutton');\n            if (debug) { window.console.log('Found closestA=', closestA); }\n            if (!closestA) {\n                if (debug) { window.console.log('This is not a targeted element so skip out'); }\n                return;\n            }\n\n            foundHref = closestA.href;\n            if (debug) { window.console.log('Found foundHref', foundHref); }\n        }\n\n        if (foundHref.length < 1) {\n            if (debug) { window.console.log('No valid href found so skip out'); }\n            return;\n        }\n\n        const requestedQuestionIndex = self.getAnchorQuestionIndex(foundHref);\n        if (debug) { window.console.log(FXN + '::Got requestedQuestionIndex=', requestedQuestionIndex); }\n        if (requestedQuestionIndex >= 0) {\n            self.firstQuestionToShow = requestedQuestionIndex;\n        }\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n    }\n\n    isWindowObj(obj) {\n        return obj && obj.document && obj.location && obj.alert && obj.setInterval;\n    }\n}\n\n/**\n * Setup the module.\n *\n * @param {number} questionsperpage How many quiz questions to show at once.\n */\nexport const init = (questionsperpage) => {\n    let debug = false;\n    const FXN = 'block_quizonepagepaginate::init';\n    if (debug) { window.console.log(FXN + '::Started with questionsperpage=' + questionsperpage); }\n\n    try {\n        M.block_quizonepagepaginate = new block_quizonepagepaginate(questionsperpage);\n        //if (debug) { window.console.log('M.block_quizonepagepaginate::Built class=', M.block_quizonepagepaginate); }\n        M.block_quizonepagepaginate.run();\n    } catch (e) {\n        window.console.error(e);\n    }\n};"],"names":["block_quizonepagepaginate","constructor","questionsperpage","FXN","this","name","shouldUseThisBlockJs","isNaN","parseInt","firstQuestionToShow","eltQuestionsSelector","eltQuizFinishAttemptButtonSelector","eltBqoppButtonPrev","eltBqoppButtonNext","arrQuestions","run","self","getAllQuestions","addNextPrevButtons","window","addEventListener","handleAnchorChange","requestedQuestionIndex","getAnchorQuestionIndex","document","URL","hideShowQuestions","undefined","shouldUseThisBlockJsVal","body","id","url","questionIndex","anchor","getAnchor","length","questionNrRequested","getAnchorQuestionNr","findQuestionIndexFromQuestionNr","split","regexResults","match","questionNr","indexFound","console","log","forEach","elt","index","querySelectorAll","first","M","last","countVisible","setDisplayVal","scrollToQuestion","querySelector","scrollIntoView","behavior","displayVal","style","display","eltCloneSource","stringsToRetrieve","key","component","require","str","get_strings","then","stringsRetrieved","addPrevNextButton","buttonClickedPrev","buttonClickedNext","nextorprev","strings","eltClone","cloneNode","isPrev","prevval","prevdisplay","setAttribute","getAttribute","replace","parentNode","insertBefore","updateVisibleQuestionRange","getNextSet","lengthToShow","lastOfAllQs","proposedStart","e","target","srcElement","foundHref","isWindowObj","location","href","closest","closestA","obj","alert","setInterval","error"],"mappings":"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"}