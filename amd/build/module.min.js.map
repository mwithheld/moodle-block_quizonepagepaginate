{"version":3,"file":"module.min.js","sources":["../src/module.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * JS for this plugin.\n *\n * @copyright   IntegrityAdvocate.com\n * @license     https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n/* global window, M */\n/* eslint-env es6, node */\n/* eslint-disable no-control-regex, no-alert, max-len */\n\nclass block_quizonepagepaginate {\n    constructor(questionsperpage) {\n        let debug = false;\n        let self = this;\n        const FXN = self.constructor.name + '.constructor';\n        if (debug) { window.console.log(FXN + '::Started with questionsperpage=', questionsperpage); }\n\n        if (isNaN(questionsperpage)) {\n            throw FXN + '::Invalid value passed for param questionsperpage';\n        }\n\n        // How many quiz questions to show at one time.\n        self.questionsperpage = parseInt(questionsperpage);\n        // The index of the first quiz question to show.\n        self.firstQuestionToShow = 0;\n\n        // Used to locate the quiz questions on the page.\n        self.eltQuestionsSelector = '#page-mod-quiz-attempt #responseform .que';\n        // Used to place this plugin's JS-driven next/prev nav buttons.\n        self.eltQuizFinishAttemptButtonSelector = '#responseform .submitbtns .mod_quiz-next-nav';\n        // Button to show tne previous questions.\n        self.eltBqoppButtonPrev = self.constructor.name + '-prev';\n        // Button to show tne next questions.\n        self.eltBqoppButtonNext = self.constructor.name + '-next';\n\n        // Holds all the current page quiz questions, visible or not.\n        self.arrQuestions = [];\n    }\n\n    run() {\n        let debug = false;\n        let self = this;\n        const FXN = self.constructor.name + '.run';\n        if (debug) { window.console.log(FXN + '::Started with self.firstQuestionToShow=; self.questionsperpage=', self.firstQuestionToShow, self.questionsperpage); }\n\n        self.getAllQuestions();\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n        self.addNextPrevButtons();\n    }\n\n    getAllQuestions() {\n        let debug = false;\n        let self = this;\n        const FXN = self.constructor.name + '.getAllQuestions';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        self.arrQuestions = document.querySelectorAll(self.eltQuestionsSelector);\n        if (debug) { window.console.log(FXN + '::Found ' + self.arrQuestions.length + ' questions on the page'); }\n    }\n\n    hideShowQuestions(first = 0, length) {\n        let debug = false;\n        let self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.hideShowQuestions';\n        if (debug) { window.console.log(FXN + '::Started with start=; length=', first, length); }\n\n        const last = first + length;\n        let countVisible = 0;\n\n        self.arrQuestions.forEach(function(elt, index) {\n            if (debug) { window.console.log(FXN + '::Looking at index=; elt=', index, elt); }\n            if (index >= first && index < last && countVisible < self.questionsperpage) {\n                if (debug) { window.console.log(FXN + '::Show this elt'); }\n                self.setDisplayVal(elt, 'block');\n                countVisible++;\n            } else {\n                if (debug) { window.console.log(FXN + '::Hide this elt'); }\n                self.setDisplayVal(elt, 'none');\n            }\n        });\n    }\n\n    setDisplayVal(elt, displayVal) {\n        if (elt.style.display !== displayVal) {\n            elt.style.display = displayVal;\n        }\n    }\n\n    addNextPrevButtons() {\n        let debug = false;\n        let self = this;\n        const FXN = self.constructor.name + '.addNextPrevButtons';\n        if (debug) { window.console.log(FXN + '::Started with self.eltQuizFinishAttemptButtonSelector=', self.eltQuizFinishAttemptButtonSelector); }\n\n        let eltCloneSource = document.querySelector(self.eltQuizFinishAttemptButtonSelector);\n\n        // String are returned in a plain array in the same order specified here.\n        // E.g. [0 => \"Previous\", 1 => \"Next\"].\n        const stringsToRetrieve = [{\n                key: 'previous',\n                component: 'core'\n            },\n            {\n                key: 'next',\n                component: 'core',\n            }\n        ];\n\n        // We need core/str bc we get column names via ajax get_string later.\n        require(['core/str'], function(str) {\n            if (debug) { window.console.log(FXN + '.require::Started with stringsToRetrieve=', stringsToRetrieve); }\n\n            str.get_strings(stringsToRetrieve).then(\n                function(stringsRetrieved) {\n                    if (debug) { window.console.log(FXN + '.require.get_strings.then::Started with stringsRetrieved=', stringsRetrieved); }\n\n                    let eltPrevInDom = self.addPrevNextButton(eltCloneSource, 'prev', stringsRetrieved);\n                    eltPrevInDom.addEventListener('click', self.buttonClickedPrev);\n\n                    let eltNextInDom = self.addPrevNextButton(eltCloneSource, 'next', stringsRetrieved);\n                    eltNextInDom.addEventListener('click', self.buttonClickedNext);\n                });\n        });\n    }\n\n    /**\n     *\n     * @param {DomElement} eltCloneSource\n     * @param {string} nextorprev\n     * @param {Array<string>} strings\n     * @returns The DomElement we just inserted\n     */\n    addPrevNextButton(eltCloneSource, nextorprev, strings) {\n        let eltClone = eltCloneSource.cloneNode();\n        const prevval = (nextorprev == 'prev' ? self.eltBqoppButtonPrev : self.eltBqoppButtonNext);\n        const prevdisplay = strings[(nextorprev == 'prev' ? 0 : 1)];\n        eltClone.setAttribute('id', prevval);\n        eltClone.setAttribute('class', eltClone.getAttribute('class').replace('btn-primary', 'btn-secondary'));\n        eltClone.setAttribute('name', prevval);\n        eltClone.setAttribute('type', prevval);\n        eltClone.setAttribute('value', prevdisplay);\n        eltClone.setAttribute('data-initial-value', prevdisplay);\n\n        return eltCloneSource.parentNode.insertBefore(eltClone, eltCloneSource);\n    }\n\n    buttonClickedPrev() {\n        let debug = false;\n        let self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.buttonClickedPrev';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        self.updateVisibleQuestionRange(false);\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n    }\n\n    buttonClickedNext() {\n        let debug = false;\n        let self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.buttonClickedNext';\n        if (debug) { window.console.log(FXN + '::Started'); }\n\n        self.updateVisibleQuestionRange(true);\n        self.hideShowQuestions(self.firstQuestionToShow, self.questionsperpage);\n    }\n\n    updateVisibleQuestionRange(getNextSet = true) {\n        let debug = false;\n        let self = M.block_quizonepagepaginate;\n        const FXN = self.constructor.name + '.updateVisibleQuestionRange';\n        if (debug) {\n            window.console.log(FXN + '::Started with getNextSet=', getNextSet);\n        }\n\n        let firstOfAllQs = 0;\n        let lengthToShow = self.questionsperpage;\n        let lastOfAllQs = self.arrQuestions.length;\n        if (debug) { window.console.log(FXN + '::Start; firstOfAllQs=' + firstOfAllQs + '; lengthToShow=' + lengthToShow + '; lastOfAllQs=' + lastOfAllQs); }\n\n        if (getNextSet) {\n            // Propose to jump to the next set of questions.\n            let proposedStart = self.firstQuestionToShow + lengthToShow;\n            if (debug) { window.console.log(FXN + '::Proposed start of the next set of questions=', proposedStart); }\n\n            // Check that the [proposed range of setLength questions] is within the [total range of questions].\n            if (proposedStart + lengthToShow < lastOfAllQs) {\n                self.firstQuestionToShow = proposedStart;\n                if (debug) { window.console.log(FXN + '::The proposedStart + lengthToShow is below the max range, so set self.firstQuestionToShow=', self.firstQuestionToShow); }\n            } else {\n                self.firstQuestionToShow = lastOfAllQs - lengthToShow;\n                if (debug) { window.console.log(FXN + '::The proposedStart + lengthToShow is above the max range, so set self.firstQuestionToShow=', self.firstQuestionToShow); }\n            }\n        } else {\n            // Propose to jump to the next set of questions.\n            let proposedStart = self.firstQuestionToShow - lengthToShow;\n            window.console.log(FXN + '::Proposed start of the next set of questions=', proposedStart);\n\n            // Check that the [proposed range of setLength questions] is within the [total range of questions].\n            if (proposedStart < firstOfAllQs) {\n                if (debug) { window.console.log(FXN + '::The proposedStart is below the min range, so set self.firstQuestionToShow=', self.firstQuestionToShow); }\n                self.firstQuestionToShow = firstOfAllQs;\n            } else {\n                if (debug) { window.console.log(FXN + '::The proposedStart is within the min range, so set self.firstQuestionToShow=', self.firstQuestionToShow); }\n                self.firstQuestionToShow = proposedStart;\n            }\n        }\n\n        if (debug) { window.console.log(FXN + '::Done; firstOfAllQs=' + firstOfAllQs + '; lengthToShow=' + lengthToShow + '; lastOfAllQs=' + lastOfAllQs); }\n    }\n}\n\n/**\n * Setup the module.\n *\n * @param {number} questionsperpage How many quiz questions to show at once.\n */\nexport const init = (questionsperpage) => {\n    let debug = false;\n    const FXN = 'block_quizonepagepaginate::init';\n    if (debug) { window.console.log(FXN + '::Started with questionsperpage=' + questionsperpage); }\n\n    try {\n        M.block_quizonepagepaginate = new block_quizonepagepaginate(questionsperpage);\n        //if (debug) { window.console.log('M.block_quizonepagepaginate::Built class=', M.block_quizonepagepaginate); }\n        M.block_quizonepagepaginate.run();\n    } catch (e) {\n        window.console.log.error(e);\n    }\n};"],"names":["block_quizonepagepaginate","constructor","questionsperpage","FXN","this","name","isNaN","parseInt","firstQuestionToShow","eltQuestionsSelector","eltQuizFinishAttemptButtonSelector","eltBqoppButtonPrev","eltBqoppButtonNext","arrQuestions","run","self","getAllQuestions","hideShowQuestions","addNextPrevButtons","document","querySelectorAll","first","length","M","last","countVisible","forEach","elt","index","setDisplayVal","displayVal","style","display","eltCloneSource","querySelector","stringsToRetrieve","key","component","require","str","get_strings","then","stringsRetrieved","addPrevNextButton","addEventListener","buttonClickedPrev","buttonClickedNext","nextorprev","strings","eltClone","cloneNode","prevval","prevdisplay","setAttribute","getAttribute","replace","parentNode","insertBefore","updateVisibleQuestionRange","getNextSet","lengthToShow","lastOfAllQs","proposedStart","window","console","log","e","error"],"mappings":"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"}